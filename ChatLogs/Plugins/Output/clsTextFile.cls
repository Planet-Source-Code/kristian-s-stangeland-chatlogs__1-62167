VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsTextFile"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

' Copyright (C) 2005 Kristian S. Stangeland

' This program is free software; you can redistribute it and/or
' modify it under the terms of the GNU General Public License
' as published by the Free Software Foundation; either version 2
' of the License, or (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

Property Get MenuCaption() As String

    ' This module dosen't require any caption
    MenuCaption = ""
    
End Property

Property Get FileFilter() As String

    ' The filter used to browse for such files
    FileFilter = "Messenger Plus (*.txt)" & Chr(0) & "*.txt"
    
End Property

Property Get FileExtension() As String

    ' The file extension this parser uses
    FileExtension = "txt"
    
End Property

Property Get ExportName() As String

    ' This parser is primary used to parse messenger plus
    ExportName = "MessengerPlus"

End Property

Property Get ExportHandleAll() As Boolean

    ' If this output modules will do all the work by itself
    ExportHandleAll = False

End Property

Property Get ExportHandleIO() As Boolean

    ' Whether or not the export-function does all the I/O-operations itself
    ExportHandleIO = False

End Property

Property Get ExportMayAppend() As Boolean

    ' Whether or not the export-function returns the ENTIRE file-content or simply just what needs to be appended
    ExportMayAppend = True

End Property

Property Get ExporterDescription() As String

    ' The description of this parser
    ExporterDescription = "Used to export to the log-type generated by the Messenger Plus!-plugin"

End Property

Public Function RetriveName(Session As Object, userIndex As Long) As String
    
    ' Return the second email of this session
    RetriveName = Session.Participants(userIndex).Email
    
End Function

Public Function ExportLog(Session As Object, sExistingFile As String, FileOperation As Object) As String

    On Error Resume Next
    Dim Result As New clsStringClass, User As Object, sSender As String
    Dim Tell As Long, oEvent As Object, sTime As String, sContent As String
    Dim bSaveEvents As Boolean, bAddTime As Boolean, lngMax As Long, bWordWrap As Boolean
    
    ' Get different settings
    bAddTime = (GetSetting("ChatLogs", "Settings", "MessageTime", 1) = 1)
    bSaveEvents = (GetSetting("ChatLogs", "Settings", "SaveEvents", 1) = 1)
    bWordWrap = (GetSetting("ChatLogs", "Settings", "WordWrap", 1) = 1)
    lngMax = Val(GetSetting("ChatLogs", "Settings", "MaxLenght", -1))
    
    ' See if the file is not empty
    If Dir(sExistingFile) <> "" Then
    
        ' Add a line
        Result.AppendString vbCrLf
    
    End If

    ' Add the header-section of the conversation log
    AddSeperator Result
    AddLine Result, "| Session start: " & Session.SessionDate, "|"
    AddLine Result, "| Participants:", "|"
    
    ' Then add each participants to the list
    For Each User In Session.Participants
    
        ' Add the participants username and, if it exists, email
        AddLine Result, "|    " & MinimizeString(User.NickName & IIf(User.Email <> "", " (" & User.Email & ")", ""), "...", 63, -1), "|"
    
    Next
    
    ' Conclude the header-section
    AddSeperator Result
    
    ' Now, add all events and messages
    For Each oEvent In Session.Events
        
        ' Exclude events when specified
        If Not ((Not oEvent.IsMessage) And (Not bSaveEvents)) Then
    
            ' Show we add the time?
            If bAddTime Then
        
                ' Find the type of the message
                If oEvent.IsMessage Then
                
                    ' Get the time of the message
                    sTime = "[" & TimeOnly(oEvent.MessageDate) & "] "
                
                Else
                
                    ' Add the time of the event
                    sTime = "[" & TimeOnly(oEvent.EventDate) & "] "
                
                End If
            
            End If
            
            ' Clear variables
            sSender = ""
            
            ' Retrive the sendeer
            sSender = MinimizeString(oEvent.Sender.NickName, "", lngMax, 1)
            
            ' Then add the time ...
            Result.AppendString sTime
            
            ' ... and the message
            If bWordWrap Then
                ' Use the word wrap function
                WordBreak sSender & ": " & oEvent.Text, 70, vbCrLf & Space(Len(sTime)), Result
            Else
                ' Don't use it, just print the line
                Result.AppendString sSender & ": " & oEvent.Text
            End If
            
            ' Add a new line
            Result.AppendString vbCrLf
        
        End If
            
    Next
    
    ' Return the data
    ExportLog = Result.ToString

End Function

Private Sub WordBreak(sText As String, MaxLenght As Long, sNewLine As String, Result As clsStringClass)

    Dim lngChar As Integer, lngNextPos As Long, lngLastPos As Long, lngLastBreak As Long
    Dim lngNewLine As Long, intChar() As Integer, SafeArray As SAFEARRAY1D
    
    ' Initialize string
    InitializeArray intChar, SafeArray, sText
    
    ' Set the default positions
    lngLastBreak = -1
    lngNextPos = 1
    lngLastPos = 1
    
    ' And get different string lenghts
    lngNewLine = Len(sNewLine)
    
    ' Loop through the text, forcing line breaks where it's nesseccary
    For lngNextPos = 1 To Len(sText)
        
        ' Get the current character
        lngChar = intChar(lngNextPos)
        
        ' A space-character
        If lngChar = 32 Then
        
            ' Check and see if wee need to break the line
            If lngNextPos - lngLastBreak + lngNewLine > MaxLenght Then
            
                ' Force a break line
                Result.AppendString IIf(lngLastBreak > 0, sNewLine, "") & Mid(sText, lngLastBreak + 2, lngNextPos - lngLastBreak - 2)
                
                ' Set this position as a line break (move backwards two character to emulate it)
                lngLastBreak = lngNextPos - 1
            
            End If
            
            ' Save this as the last space position
            lngLastPos = lngNextPos

        End If
        
        ' The beginning of an line break or the end of the string
        If lngChar = 13 Or lngNextPos = Len(sText) Then
        
            ' Add this line to the collection
            Result.AppendString IIf(lngLastBreak > 0, sNewLine, "") & Mid(sText, lngLastBreak + 2, lngNextPos - lngLastBreak - 1)
            
            ' Let the line break begin at this position plus one
            lngLastBreak = lngNextPos

        End If

    Next

    ' Clear the array
    ZeroMemory VarPtrArray(intChar), 4

End Sub

Private Function TimeOnly(dDate As Date) As Date

    ' Return only the time-part
    TimeOnly = TimeSerial(Hour(dDate), Minute(dDate), Second(dDate))
    
End Function

Private Function MinimizeString(sString As String, sAbbrivation As String, MaxLenght As Long, Direction As Long) As String

    ' Firstly, see if any abbrivation is nesseccary
    If Len(sString) <= MaxLenght Or (Direction = 0) Or (MaxLenght < 0) Then

        ' Nope, just return the string
        MinimizeString = sString
        
    Else
    
        ' Minimize the string depending of the directon
        If Direction > 0 Then
        
            ' Mimimize from right
            MinimizeString = Mid(sString, 1, MaxLenght - Len(sAbbrivation)) & sAbbrivation
        
        Else
        
            ' Minimize from left
            MinimizeString = sAbbrivation & Mid(sString, Len(sString) - MaxLenght + 1 + Len(sAbbrivation))
        
        End If

    End If

End Function

Private Sub AddLine(sClass As clsStringClass, sText As String, sEnd As String)

    ' Add the line to the log
    sClass.AppendString sText & String(70 - Len(sText) - Len(sEnd), " ") & sEnd & vbCrLf

End Sub

Private Sub AddSeperator(sClass As clsStringClass)

    ' Add a seperator-line to the class
    sClass.AppendString "." & String(68, "-") & "." & vbCrLf

End Sub
