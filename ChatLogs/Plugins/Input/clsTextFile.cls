VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsTextFile"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

' Copyright (C) 2005 Kristian S. Stangeland

' This program is free software; you can redistribute it and/or
' modify it under the terms of the GNU General Public License
' as published by the Free Software Foundation; either version 2
' of the License, or (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

Property Get FileFilter() As String

    ' The filter used to browse for such files
    FileFilter = "Messenger Plus (*.txt)" & Chr(0) & "*.txt"
    
End Property

Property Get FileExtension() As String

    ' The file extension this parser uses
    FileExtension = "txt"
    
End Property

Property Get ParserHandleIO() As Boolean

    ' Whether or not the parser handles I/O iself
    ParserHandleIO = False

End Property

Property Get ParserName() As String

    ' This parser is primary used to parse messenger plus
    ParserName = "MessengerPlus"

End Property

Property Get ParserDeliverString() As Boolean

    ' Whether or not we're awaiting a string or a byte array
    ParserDeliverString = True

End Property

Property Get ParserDescription() As String

    ' The description of this parser
    ParserDescription = "Used to parse logs generated by the Messenger Plus!-plugin"

End Property

Public Sub ParserInitialize()

    ' We are about to begin

End Sub

Public Sub ParseDocument(LogData As String, LogClass As Object)

    On Error Resume Next
    Dim Lines As Variant, LineIndex As Long, lngStart As Long, sName As String
    Dim SessionDate As Date, Participants() As Variant, ArrayCount As Long
    Dim currSession As Object, EventDate As Date, lngEnd As Long, sText As String
    Dim currUser As Collection, remainingUsers As Collection, Tell As Long
    Dim LastDate As Date, Sender As Object, sDate As String, LastTime As Date
    
    ' Firstly, we need to split everything into lines
    Lines = Split(LogData, vbCrLf)

    ' Loop through all lines to find all sessions
    Do
    
        ' Move forward to a line that starts with a certain character
        LineIndex = FindLine(Lines, LineIndex, "|")
    
        ' If we didn't find anything, end the search
        If LineIndex < 0 Then
            Exit Do
        End If
        
        ' Clear all errors
        Err.Clear
        
        ' Get the date from the file
        sDate = Trim(CutString(CStr(Lines(LineIndex)), InStr(1, Lines(LineIndex), ": ") + 2, Len(Lines(LineIndex)) - 1))
        
        ' The first line is the date of the session
        SessionDate = CDate(sDate)
    
        ' Check wheather or not this went without errors
        If Err.Number <> 0 Then
        
            ' We'll try to tweak the date a little - simply by removing the first partion of the date
            SessionDate = CDate(Mid(sDate, InStr(1, sDate, ",") + 1))
            
        End If
    
        ' Reset the array count
        ArrayCount = -1
    
        ' Increse line index
        LineIndex = LineIndex + 2
    
        ' The next lines is all the participants of this conversation
        Do Until LineIndex > UBound(Lines)
            
            ' Check and see if this is the last line
            If Mid(Lines(LineIndex), 1, 1) = "." Then
                
                ' Go to next line
                LineIndex = LineIndex + 1
                
                ' Yup, end search
                Exit Do
            
            End If
        
            ' Get name and email
            sName = Trim(Mid(Lines(LineIndex), 5, Len(Lines(LineIndex)) - 6))
        
            ' Increse array count
            ArrayCount = ArrayCount + 1
        
            ' Then reallocate array
            ReDim Preserve Participants(ArrayCount)
        
            ' Get the start of the email
            lngStart = InStrRev(sName, "(")
        
            ' Then add it to the array
            Participants(ArrayCount) = Array(Mid(sName, 1, lngStart - 2), Mid(sName, lngStart + 1, Len(sName) - lngStart - 1))
        
            ' Increse the line index
            LineIndex = LineIndex + 1
            
        Loop

        ' Add the session to the log
        Set currSession = LogClass.AddSession(SessionDate, Participants)

        ' Initiailize both collections
        Set currUser = New Collection
        Set remainingUsers = New Collection
    
        ' Then get the current user
        currUser.Add currSession.Participants(1)
        
        ' And get the remaining users
        For Tell = 2 To currSession.Participants.Count
        
            ' Add this user
            remainingUsers.Add currSession.Participants(Tell)
        
        Next
        
        ' The default value
        LastDate = SessionDate
        
        ' Now we're going to add all events and messages
        Do Until LineIndex > UBound(Lines)
        
            ' If the line is empty, we've reach the end of the session
            If Lines(LineIndex) = "" Then
                Exit Do
            End If
        
            ' Get the date of this event or message
            lngStart = InStr(1, Lines(LineIndex), "]")
            lngEnd = InStr(lngStart + 1, Lines(LineIndex), ": ")
            EventDate = CDate(Mid(Lines(LineIndex), 2, lngStart - 2))
            
            ' If the time is lett than the last, increase the date
            If EventDate < LastTime Then
                LastTime = EventDate
                LastDate = IncreaseDay(LastDate)
                EventDate = EventDate + LastDate
            Else
                LastTime = EventDate
                EventDate = EventDate + LastDate
            End If
        
            ' Check if this is an event or a message
            If Mid(Lines(LineIndex), lngStart + 2, 1) = "*" Or lngEnd = 0 Then
            
                ' Get the text
                RetriveText sText, Lines, LineIndex, lngEnd
                
                ' Add the event
                currSession.AddEvent EventDate, Mid(sText, InStr(1, sText, "]") + 2)
                
            Else ' This is a message
            
                ' Find the nickname/email of the sender
                sName = Mid(Lines(LineIndex), lngStart + 2, lngEnd - lngStart - 2)
                
                ' Get the text
                RetriveText sText, Lines, LineIndex, lngEnd
                
                ' Now, try to get the sender
                Set Sender = currSession.FindUser(sName)
                
                ' See if the sender is the current user
                If Sender Is currUser.Item(1) Then
                
                    ' Then the reciver(s) is the remaining user(s) in the conversation
                    currSession.AddMessage EventDate, Sender, remainingUsers, sText
            
                Else
                
                    ' The reciver is us
                    currSession.AddMessage EventDate, Sender, currUser, sText
                
                End If
                
            
            End If
        
            ' Increse the line index
            LineIndex = LineIndex + 1
        
        Loop
    
    Loop

End Sub

Private Function IncreaseDay(dDate As Date) As Date

    ' Increse the date by one day
    IncreaseDay = DateSerial(Year(dDate), Month(dDate), Day(dDate) + 1)

End Function

Private Sub RetriveText(sText As String, Lines As Variant, LineIndex As Long, lngEnd As Long)

    Dim bForced As Boolean, FirstWord As Long

    ' Get the text from this line
    sText = Mid(Lines(LineIndex), lngEnd + 2)

    ' Loop until all text has been recived
    Do
    
        ' Go to next line
        LineIndex = LineIndex + 1
        
        If Not (Lines(LineIndex) = "" Or Mid(Lines(LineIndex), 1, 1) = "[") Then
        
            ' Find the end-position of the first word in this line
            FirstWord = InStr(12, Lines(LineIndex), " ")
            
            ' If there aren't any, assme the end-position is the last character
            If FirstWord <= 0 Then
                FirstWord = Len(Lines(LineIndex))
            End If
            
            ' See wheather or not this was a forced line break
            bForced = CBool((Len(Lines(LineIndex - 1)) + FirstWord - 12) > 70)
        
            ' Add the text
            sText = sText & IIf(bForced, " ", vbCrLf) & Mid(Lines(LineIndex), 12)
        
        Else
        
            ' We need to move the index cursor backwards, so it will be read in the next cycle
            LineIndex = LineIndex - 1
        
            ' Just exit the loop
            Exit Do
        
        End If
        
    Loop

End Sub

Private Function CutString(sString As String, lngStart As Long, lngEnd As Long) As String

    ' Return the cutted string
    CutString = Mid(sString, lngStart, lngEnd - lngStart)

End Function

Private Function FindLine(aArray As Variant, lngStart As Long, sFind As String) As Long

    Dim Tell As Long
    
    ' Start searching for the character in the lines
    For Tell = lngStart To UBound(aArray)
    
        ' See if it is in this line
        If InStr(1, aArray(Tell), sFind, vbTextCompare) <> 0 Then
    
            ' Return the line index if so
            FindLine = Tell
            
            ' We are finished
            Exit Function
    
        End If
    
    Next
    
    ' No line was found
    FindLine = -1

End Function
