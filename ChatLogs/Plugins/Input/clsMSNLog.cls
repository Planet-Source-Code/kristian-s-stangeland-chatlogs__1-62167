VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsMSNLog"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

' Copyright (C) 2005 Kristian S. Stangeland

' This program is free software; you can redistribute it and/or
' modify it under the terms of the GNU General Public License
' as published by the Free Software Foundation; either version 2
' of the License, or (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

' Used to optimize wating
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

' The different event-types
Enum eEventType
    Event_Unknown
    Event_Invitation
    Event_InvitationResponse
    Event_Join
    Event_Leave
End Enum

' Information concering the primary and secondary user
Private PrimaryEmail As String, PrimaryNickName As String
Private SecondaryEmail As String, SecondaryNick As String

' The DOMDocument to use
Private DOMDocument As DOMDocument

Property Get FileFilter() As String

    ' The filter used to browse for such files
    FileFilter = "MSN Messenger (*.xml)" & Chr(0) & "*.xml"
    
End Property

Property Get ParserHandleIO() As Boolean

    ' Whether or not the parser handles I/O iself
    ParserHandleIO = True

End Property

Property Get FileExtension() As String

    ' The file extension this parser uses
    FileExtension = "xml"
    
End Property

Property Get ParserDeliverString() As Boolean

    ' Whether or not we're awaiting a string or a byte array
    ParserDeliverString = True

End Property

Property Get ParserName() As String

    ' This parser is primary used to parse messenger plus
    ParserName = "MSN Messenger"

End Property

Property Get ParserDescription() As String

    ' The description of this parser
    ParserDescription = "Used to parse logs generated by MSN Messenger"

End Property

Public Sub ParserInitialize()

    ' We need to ask the user some vital questions
    frmMSNLog.LoadAll
    frmMSNLog.Show
    
    ' Now, wait until some action has been taken
    Do Until frmMSNLog.Tag <> ""
        DoEvents
        Sleep 10
    Loop

End Sub

Private Function GetEmailFromFile(sFile As String) As String

    Dim sBuffer As String, Tell As Long

    ' Remove the path
    sBuffer = GetFileName(sFile)

    ' Remove the extension
    sBuffer = GetNoExtension(sBuffer)

    ' Now, find the first occurences of a non-number
    For Tell = Len(sBuffer) To 1 Step -1
    
        ' If this character is numeric, ...
        If Not IsNumeric(Mid(sBuffer, Tell, 1)) Then
        
            ' ... stop searching
            Exit For
        
        End If
    
    Next
    
    ' Now, return what we've found
    GetEmailFromFile = Left(sBuffer, Tell)

End Function

Public Function GetFileName(sFile As String) As String

    ' Return the file name
    GetFileName = Right(sFile, Len(sFile) - InStrRev(sFile, "\"))

End Function

Public Function GetFilePath(sFile As String) As String

    ' Get the path
    GetFilePath = Left(sFile, InStrRev(sFile, "\"))

End Function

Public Function GetNoExtension(sFile As String) As String

    ' "Remove" the extension from the file name
    GetNoExtension = Left(sFile, InStrRev(sFile, ".") - 1)

End Function

Public Sub ParseDocument(LogData As String, LogClass As Object)

    On Error Resume Next
    Dim MessageElement As Object, lastSessionID As Long, currSessionID As Long, sNodeName As String
    Dim currSession As Object, Participants As Collection, oSender As Object, aEmpty As Variant
    Dim Reciever, aReciever As Collection, currMessage As Object, Text As IXMLDOMElement, Trillian As Object

    ' Retrive the primary user's email and nickname
    PrimaryEmail = GetSetting("ChatLogs", "Settings", "PrimaryUserEmail", "")
    PrimaryNickName = GetSetting("ChatLogs", "Settings", "PrimaryUserNick", "")

    ' Then try to retrive the secondary email
    SecondaryEmail = GetEmailFromFile(LogClass.LogName)

    ' Create a new empty document
    Set DOMDocument = New DOMDocument

    ' Load the XML-data
    DOMDocument.Load "file:\\" & LogData
    
    ' See if we've gotten a parse error
    If DOMDocument.parseError.errorCode <> 0 Then
    
        ' This error usually indicates that this is a trillian-log
        If DOMDocument.parseError.errorCode = -1072896683 Then
        
            ' Create the trillian-class
            Set Trillian = New clsTrillian
            
            ' Give the parsing-task to this object insted
            Trillian.ParseDocument LoadFile(LogData), LogClass
        
        Else

            ' Just inform about the error
            MsgBox "A parse error (" & DOMDocument.parseError.errorCode & ") occured in " & GetFileName(LogClass.LogName) & " at line " & _
                    DOMDocument.parseError.Line & ", position " & DOMDocument.parseError.linepos & ":" & vbCrLf & _
                     DOMDocument.parseError.reason, vbCritical
             
        End If
             
        ' No point going further now
        Exit Sub
    
    End If
        
    ' Go through each message in the first log-element
    For Each MessageElement In DOMDocument.documentElement.childNodes
    
        ' Initialize participants
        Set Participants = New Collection
    
        ' Firstly, get the session id
        currSessionID = MessageElement.Attributes.getNamedItem("SessionID").nodeValue
            
        ' If this differ from the last session, create a new one
        If currSessionID <> lastSessionID Then
        
            ' Create a new session
            Set currSession = LogClass.AddSession(MessageElement.Attributes.getNamedItem("Date").nodeValue, aEmpty)
        
            ' Save this sessionID
            lastSessionID = currSessionID
        
        End If
        
        ' Retrive the nodename
        sNodeName = MessageElement.nodeName
        
        ' Get the sender
        Set oSender = RetriveUsers(MessageElement, currSession, "From")(1)
            
        ' Then add the user name if it don't already exist
        If Not IsUser(Participants, oSender) Then
            Participants.Add oSender
        End If
        
        ' The receiver of an event MUST be the primary user, so only at a message the following is necessary
        If sNodeName = "Message" Then
        
            Set aReciever = RetriveUsers(MessageElement, currSession, "To")
            
            ' Add all recievers as well
            For Each Reciever In aReciever
                If Not IsUser(Participants, Reciever) Then
                    Participants.Add Reciever
                End If
            Next
        
        End If
            
        ' Get the text-element containing style and text information
        Set Text = MessageElement.getElementsByTagName("Text")(0)
    
        Select Case sNodeName
        Case "Message"
        
            ' Add the message
            Set currMessage = currSession.AddMessage(CDate(MessageElement.Attributes. _
             getNamedItem("Date").nodeValue) + CDate(MessageElement.Attributes.getNamedItem("Time").nodeValue), _
              oSender, aReciever, Text.firstChild.nodeValue, Text.Attributes.getNamedItem("Style").nodeValue)

        Case Else
        
            ' Add an event
            currSession.AddEvent CDate(MessageElement.Attributes.getNamedItem("Date").nodeValue) _
             + CDate(MessageElement.Attributes.getNamedItem("Time").nodeValue), Text.firstChild.nodeValue, _
              EventNameToIndex(sNodeName), oSender
            
        End Select
    
    Next

End Sub

Private Function EventNameToIndex(sName As String) As Long

    ' Fint the correct index of an event-type
    Select Case sName
    Case "Invitation": EventNameToIndex = Event_Invitation
    Case "InvitationResponse": EventNameToIndex = Event_InvitationResponse
    Case "Join": EventNameToIndex = Event_Join
    Case "Leave": EventNameToIndex = Event_Leave
    Case Else: EventNameToIndex = Event_Unknown
    End Select

End Function

Private Function FindEmail(sNickName As String, sQuery As String, sEmail As String, sReturn As String) As Boolean

    ' Don't bother testing if the email is empty
    If LenB(sEmail) = 0 Then
        Exit Function
    End If

    ' If the nickname corresponds to the query, ...
    If InStr(1, sNickName, sQuery, vbTextCompare) <> 0 Then
            
        ' ... use this email address
        sReturn = sEmail
        
        ' And return true
        FindEmail = True
        
    Else
    
        ' Nope, thing was found
        sReturn = ""
    
    End If
        
End Function

Private Function RetriveUsers(MessageElement As IXMLDOMElement, currSession As Object, tagName As String) As Collection

    Dim User As IXMLDOMElement, sNickName As String, sEmail As String, currUser As Object

    ' Firstly, create a new collection
    Set RetriveUsers = New Collection
    
    ' Then get all subelements
    For Each User In MessageElement.getElementsByTagName(tagName).Item(0).childNodes
    
        ' Retrive the nickname
        sNickName = User.Attributes.getNamedItem("FriendlyName").nodeValue
    
        ' Try to find the email-address
        If Not FindEmail(sNickName, PrimaryNickName, PrimaryEmail, sEmail) Then
            
            ' If it dosen't correspond to the primary email, we've most likely got the other user
            sEmail = SecondaryEmail
        
        End If
    
        ' Get the user based on this string
        Set currUser = currSession.FindUser(sNickName & sEmail)
    
        ' If the user already has been aadded, use this class insted of adding it
        If currUser Is Nothing Then
        
            ' Add the user to the collection after adding it to the lists
            RetriveUsers.Add currSession.AddParticipant(sNickName, sEmail)
            
        Else
        
            ' Simply add the user to the collection
            RetriveUsers.Add currUser
        
        End If

    Next

End Function

Private Function IsUser(colParticipants As Collection, refUser As Variant) As Boolean

    Dim User As Object
    
    ' If the collection hasn't yet been initialized, surely no users can be found
    If colParticipants Is Nothing Then
        Exit Function
    End If
    
    ' Go through each user registered
    For Each User In colParticipants
    
        ' Check the username and email, and see if either of them is equal
        If User.NickName = refUser.NickName Or User.Email = refUser.Email Then
        
            ' Yup, return true
            IsUser = True
            
            ' We are finished with the searching - nothing can change the outcome now
            Exit For
        
        End If
    
    Next

End Function
