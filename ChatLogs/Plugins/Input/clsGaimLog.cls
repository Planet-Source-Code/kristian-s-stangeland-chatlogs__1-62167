VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsGaimLog"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

' Copyright (C) 2005 Kristian S. Stangeland

' This program is free software; you can redistribute it and/or
' modify it under the terms of the GNU General Public License
' as published by the Free Software Foundation; either version 2
' of the License, or (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

' The DOMDocument to use
Private DOMDocument As DOMDocument

Property Get FileFilter() As String

    ' The filter used to browse for such files
    FileFilter = "Gaim Chat-log (*.html)" & Chr(0) & "*.html"
    
End Property

Property Get ParserHandleIO() As Boolean

    ' Whether or not the parser handles I/O iself
    ParserHandleIO = False

End Property

Property Get FileExtension() As String

    ' The file extension this parser uses
    FileExtension = "html"
    
End Property

Property Get ParserDeliverString() As Boolean

    ' Whether or not we're awaiting a string or a byte array
    ParserDeliverString = False

End Property

Property Get ParserName() As String

    ' This parser is primary used to parse messenger plus
    ParserName = "Gaim Chat-log"

End Property

Property Get ParserDescription() As String

    ' The description of this parser
    ParserDescription = "Used to parse logs generated by Gaim"

End Property

Public Sub ParserInitialize()

    ' Nothing needs to be initialized.

End Sub

Public Function GetFileName(sFile As String) As String

    ' Return the file name
    GetFileName = Right(sFile, Len(sFile) - InStrRev(sFile, "\"))

End Function

Public Sub SetArray(bArray() As Byte, lngStart As Long, lngEnd As Long, bValue As Byte)

    Dim Tell As Long
    
    ' Go through the specified bytes
    For Tell = lngStart To lngEnd

        ' Set each byte
        bArray(Tell) = bValue

    Next

End Sub

Public Function FindValue(bArray() As Byte, bValue As Byte) As Long

    Dim Tell As Long
    
    ' Go through all bytes in the array
    For Tell = LBound(bArray) To UBound(bArray)

        ' If this byte correspond, return its index
        If bArray(Tell) = bValue Then
            
            ' Return the index
            FindValue = Tell
            
            ' We're finish searching
            Exit Function
            
        End If

    Next

End Function

Public Sub ParseDocument(LogData() As Byte, LogClass As Object)

    Dim Element As Object, Body As Object, Tell As Long, bText As Boolean, sStyle As String
    Dim currSession As Object, currEvent As Object, oSender As Object, oReceiver As Object
    Dim dDate As Date, vPar As Variant, bAdded As Boolean, sFileData As String, sNick As String

    ' Create a new empty document
    Set DOMDocument = New DOMDocument

    ' The first bytes are irrelevant - set them to space
    SetArray LogData, 1, FindValue(LogData, 60) - 1, 32

    ' Convert the UTF-8 to Unicode
    sFileData = MBToUni(LogData, CP_UTF8)

    ' Because we're parsing an HTML-document as XML, we need to do some minor changes
    sFileData = Replace(sFileData, "<br>", "<br />") & "</body></html>"

    ' Load the XML-data
    DOMDocument.validateOnParse = False
    DOMDocument.async = False
    DOMDocument.loadXML sFileData
    
    ' See if we have an error
    If DOMDocument.parseError.errorCode <> 0 Then
    
        ' Inform about the error
        MsgBox "A parse error (" & DOMDocument.parseError.errorCode & ") occured in " & GetFileName(LogClass.LogName) & " at line " & _
                DOMDocument.parseError.Line & ", position " & DOMDocument.parseError.linepos & ":" & vbCrLf & _
                 DOMDocument.parseError.reason & ":" & vbNewLine & DOMDocument.parseError.srcText, vbCritical
                 
        ' No point goint further now
        Exit Sub
        
    End If
    
    ' Get the body-element
    Set Body = DOMDocument.firstChild.childNodes(1).childNodes

    ' Go through each element
    For Tell = 0 To Body.length
    
        ' Retrive this element
        Set Element = Body(Tell)
    
        ' If this element is empty, surely we've reached the end
        If Element Is Nothing Then
            Exit For
        End If
    
        Select Case LCase(Element.nodeName)
        Case "h3" ' This is the description of the chat log
        
            ' Then, split the content, making the information available
            vPar = Split(Element.Text, " ")
            
            ' Get the date of this session
            dDate = CDate(vPar(4))
            
            ' Now, create a new session
            Set currSession = LogClass.AddSession(dDate + CDate(vPar(5)), Array(Array("", vPar(7)), Array("", vPar(2))))
        
        Case "font", "b"
        
            If bText Then
            
                ' Reset variables
                sStyle = ""
            
                ' This is the text
                If LCase(Element.firstChild.nodeName) = "span" Then
                    
                    ' Get the style data
                    sStyle = Element.firstChild.Attributes.getNamedItem("style").nodeValue & _
                     Element.firstChild.firstChild.Attributes.getNamedItem("style").nodeValue
                    
                    ' Set the data
                    currEvent.Style = sStyle
                    currEvent.Text = Element.nodeTypedValue
                    
                Else
                    
                    ' Retrive the text-value and set the event/message
                    currEvent.Text = Element.nodeTypedValue
                
                End If
            
            Else
            
                ' This is the header
                If Element.childNodes.length = 1 Then
                    
                    ' We've come over a event
                    Set currEvent = currSession.AddEvent(dDate + CDate(GetSection(GetSubElement(Element, 0), 2, 1)), "")
                
                Else
                
                    ' Retrive the sender ...
                    Set oSender = currSession.Participants(IIf((UCase(Element.Attributes.getNamedItem("color").nodeValue) = "#16569E"), 1, 2))
                    Set oReceiver = New Collection
                    
                    ' ... and the reciever
                    oReceiver.Add InverseUser(currSession, oSender)
                
                    ' Retrive the nickname of the user
                    sNick = GetSection(Element.childNodes(1).Text, 1, 1)
                
                    ' Set the nickname of the sender
                    oSender.AppendNickName sNick, bAdded
                
                    ' If we in fact HAS added the nick name, add it to the session too
                    If bAdded Then
                        currSession.NickNames.Add sNick
                    End If
                
                    ' We've come over a message
                    Set currEvent = currSession.AddMessage(dDate + CDate(GetSection( _
                     GetSubElement(Element, 0), 2, 1)), oSender, oReceiver, "")
                     
                End If
             
            End If
        
            ' Whether or not this is a element containg the text of the message/event
            bText = Not bText
        
        End Select
        
    Next

End Sub

Private Function GetDateOnly(dDate As Date) As Date

    ' Return only the date
    GetDateOnly = DateSerial(Year(dDate), Month(dDate), Day(dDate))

End Function

Private Function InverseUser(Session As Object, User As Object) As Object

    Dim Participant As Object

    ' Go through all participants in the session
    For Each Participant In Session.Participants

        ' If this is NOT the user specified, return the user
        If User.Email <> Participant.Email Then
        
            ' Return this user
            Set InverseUser = Participant
            
            ' We're finish searching
            Exit For
        
        End If

    Next

End Function

Public Function GetSection(sText As String, lngStart As Long, lngEnd As Long)

    ' Return the string-section
    GetSection = Mid(sText, lngStart, Len(sText) - lngEnd - lngStart + 1)

End Function

Private Function GetSubElement(Element As Object, lngSubElement As Long)

    ' Just get the text of a subelement
    GetSubElement = Element.childNodes(lngSubElement).nodeTypedValue

End Function

Private Function IsUser(colParticipants As Collection, refUser As Variant) As Boolean

    Dim User As Object
    
    ' If the collection hasn't yet been initialized, surely no users can be found
    If colParticipants Is Nothing Then
        Exit Function
    End If
    
    ' Go through each user registered
    For Each User In colParticipants
    
        ' Check the username and see if it is equal
        If User.NickName = refUser.NickName Then
        
            ' Yup, return true
            IsUser = True
            
            ' We are finished with the searching - nothing can change the outcome now
            Exit For
        
        End If
    
    Next

End Function

